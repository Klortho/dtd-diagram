{"version":3,"sources":["DtdDiagram.js","Box.js","Node.js","HasLabelNode.js","HasQNode.js","ElementNode.js","AttributeNode.js","ChoiceSeqNode.js","ChoiceNode.js","SeqNode.js","OtherNode.js","Canvas.js","Compressor.js","StateManager.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"dtd-diagram.js","sourcesContent":["// Define a global class DtdDiagram\n\nif (typeof d3 !== \"undefined\")\n{\n  (function() {\n\n    DtdDiagram = function(constructor_opts) {\n      var diagram = this;\n      DtdDiagram.diagrams_array.push(diagram);\n      diagram.constructor_opts = constructor_opts || {};\n\n      // Defer everything else, including options handling, until document\n      // ready.\n      document_ready\n        .then(function() {\n          return diagram.initialize();\n        })\n        .then(function() {\n          return diagram.update();\n        })\n        .catch(function(err) {\n          console.error(err.stack);\n        })\n      ;\n    };\n\n    DtdDiagram.diagrams_array = [];\n    DtdDiagram.diagrams_hash = {};\n    DtdDiagram.auto_start = true;\n\n    // document_ready is a Promise that resolves when the document is ready.\n    // It simplifies making sure everything is syncronized.\n    var document_ready = DtdDiagram.document_ready =\n      new Promise(function(resolve) {\n        document.addEventListener(\"DOMContentLoaded\", resolve);\n      });\n\n    // By default, if the user hasn't instantiated an object, then\n    // we'll make one for him at document.ready.\n    document_ready.then(function() {\n      if (DtdDiagram.auto_start && DtdDiagram.diagrams_array.length == 0)\n        new DtdDiagram();\n    });\n\n    // Some constants\n    var scrollbar_margin = 20;\n\n    // Default values for all the options.\n    DtdDiagram.default_options = {\n\n      // DTD JSON file\n      dtd_json_file: \"dtd.json\",\n\n\n      // Initial state options\n\n      // The root element, by default, is specified in the DTD JSON file, but can\n      // be overridden\n      orig_root_name: null,\n\n      // The address of the current root, relative to the original root. Default\n      // is \"0\", meaning they are one and the same.\n      current_root_addr: \"0\",\n\n      // Initial expand/collapse state of the tree, starting at the current_root,\n      // as a compressed\n      // base64 string. Default is \"S\" => \"01\", meaning the root node's attributes\n      // will be collapsed, and the content expanded.\n      ec_state: \"S\",\n\n      // Initial source node address, which is relative to the current_node.\n      // Empty string means they're the same.\n      src_node_addr: \"\",\n\n      // Documentation links\n\n      // Base URL to use to create links to more documentation.\n      tag_doc_base: \"doc/#p=\",\n\n      // Function to compute the links to documentation. If this returns\n      // null, no link will be generated (by default, that's the case\n      // for `other` nodes and mml: elements other than mml:math)\n      tag_doc_url: function(node) {\n        var t = node.type,\n            n = node.name;\n\n        if ( t == \"other\" ||\n             ( t == \"element\" && n.startsWith(\"mml:\") &&\n               n != \"mml:math\") ) return null;\n\n        return node.diagram.tag_doc_base +\n          (t == \"attribute\" ? \"attr-\" : \"elem-\") +\n          n.replace(':', '_');\n      },\n\n      // Drawing dimensions and animation\n\n      // Minimum canvas dimensions\n      min_canvas_width: 800,\n      min_canvas_height: 400,\n\n      // Ratio of the separation between groups to the separation between sibling nodes\n      group_separation: 1.4,\n\n      // Duration of the animation, in milliseconds.\n      duration: 500,\n\n\n      // Event callback function for when the user clicks any of the buttons.\n      // This allows us to update the fragment identifier\n      event_handler: null,\n    };\n\n\n    // Initialize the diagram, by computing and storing the options, creating\n    // the svg element, reading the JSON dtd file, instantiating and configuring\n    // the layout engine. Returns a Promise that resolves after the JSON dtd\n    // is read.\n    DtdDiagram.prototype.initialize = function() {\n      var diagram = this;\n\n      // User can pass in a specifier for the div either as an\n      // id string or a DOM Element\n      var constructor_opts = diagram.constructor_opts,\n          container_id,\n          container_dom;\n\n      if (typeof constructor_opts.container == \"object\") {\n        container_dom = constructor_opts.container;\n        container_id = container_dom.getAttribute(\"id\");\n      }\n      else {\n        container_id = constructor_opts.container || 'dtd-diagram';\n        container_dom = document.getElementById(container_id);\n      }\n\n      if (!container_dom) {\n        console.error(\"DtdDiagram error: no container element with ID \" +\n          container + \" was found\");\n        return;\n      };\n      diagram.container_id = container_id;\n      DtdDiagram.diagrams_hash[container_id] = diagram;\n      diagram.container_dom = container_dom;\n\n      // Create the D3 selection for the container\n      var container_d3 = diagram.container_d3 = d3.select(container_dom);\n\n      // Get the initial state, either from the history.state object, or from\n      // the URL. The returned value might be null.\n      //var initial_state = diagram.get_initial_state();\n      //console.log(\"initial state: %o\", initial_state);\n\n\n      // Get the options specified on the @data-options attribute\n      var tag_opts_json = container_dom.getAttribute(\"data-options\");\n      var tag_options = tag_opts_json ? JSON.parse(tag_opts_json) : {};\n\n      // Finally, set the properties on the diagram object itself, according\n      // to precedence rules\n      DtdDiagram.extend(diagram, DtdDiagram.default_options,\n        tag_options, constructor_opts);\n\n\n      // scrollbar margin - if this is big enough, it ensures we'll never get\n      // spurious scrollbars when the drawing is at the minimum size. But if it's\n      // too big, it messes up the centering. 22 gives plenty of room\n      var min_canvas_width = diagram.min_canvas_width,\n          min_canvas_height = diagram.min_canvas_height;\n      container_d3.style({\n        'width': (min_canvas_width + scrollbar_margin) + 'px',\n        'height': (min_canvas_height + scrollbar_margin) + 'px'\n      });\n\n      // Initialize the SVG\n      var svg = diagram.svg = container_d3.append(\"svg\");\n\n      var defs = svg.append(\"defs\");\n      defs.append('defs').html(\n        '<filter id=\"dropshadow\" height=\"130%\">' +\n          '<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"3\"/>' +\n          '<feOffset dx=\"2\" dy=\"2\" result=\"offsetblur\"/>' +\n          '<feComponentTransfer>' +\n          '  <feFuncA type=\"linear\" slope=\".5\"/>' +\n          '</feComponentTransfer>' +\n          '<feMerge>' +\n          '  <feMergeNode/>' +\n          '  <feMergeNode in=\"SourceGraphic\"/>' +\n          '</feMerge>' +\n        '</filter>'\n      );\n      defs.append('defs').html(\n        '<linearGradient id=\"collapsed-linear-gradient\">' +\n        '  <stop style=\"stop-color:#787878;stop-opacity:0.39215687;\"' +\n        '        offset=\"0\"/>' +\n        '  <stop style=\"stop-color:#000000;stop-opacity:0;\"' +\n        '        offset=\"1\"/>' +\n        '</linearGradient>' +\n        '<radialGradient' +\n        '   xlink:href=\"#collapsed-linear-gradient\"' +\n        '   id=\"collapsed-fill\"' +\n        '   gradientUnits=\"userSpaceOnUse\"' +\n        '   gradientTransform=\"matrix(0.71138316,-0.67243129,1.0234543,1.0827397,-6.6025303,4.7069303)\"' +\n        '   cx=\"10.3125\"' +\n        '   cy=\"9.359375\"' +\n        '   fx=\"10.3125\"' +\n        '   fy=\"9.359375\"' +\n        '   r=\"7.5\" />'\n      );\n      defs.append('defs').html(\n        '<linearGradient id=\"expanded-linear-gradient\">' +\n        '  <stop style=\"stop-color:#787878;stop-opacity:0.58823532;\"' +\n        '        offset=\"0\"/>' +\n        '  <stop style=\"stop-color:#000000;stop-opacity:0;\"' +\n        '        offset=\"1\"/>' +\n        '</linearGradient>' +\n        '<radialGradient' +\n        '   xlink:href=\"#expanded-linear-gradient\"' +\n        '   id=\"expanded-fill\"' +\n        '   gradientUnits=\"userSpaceOnUse\"' +\n        '   gradientTransform=\"matrix(0.60291662,-0.63555279,0.73595623,0.69816422,-4.6918189,8.0214032)\"' +\n        '   cx=\"12.196308\"' +\n        '   cy=\"3.283603\"' +\n        '   fx=\"12.196308\"' +\n        '   fy=\"3.283603\"' +\n        '   r=\"7.5\" />'\n      );\n      defs.append('defs').html(\n        '<linearGradient id=\"hover-linear-gradient\">' +\n        '  <stop style=\"stop-color:#ffffff;stop-opacity:0.58823532;\"' +\n        '        offset=\"0\"/>' +\n        '  <stop style=\"stop-color:#000000;stop-opacity:0;\"' +\n        '        offset=\"1\"/>' +\n        '</linearGradient>' +\n        '<radialGradient ' +\n        '   xlink:href=\"#hover-linear-gradient\"' +\n        '   id=\"hover-gradient\"' +\n        '   gradientUnits=\"userSpaceOnUse\"' +\n        '   gradientTransform=\"matrix(0.98751557,-0.85565774,1.0673114,1.2317852,-10.470545,8.953672)\"' +\n        '   cx=\"12.196308\"' +\n        '   cy=\"3.283603\"' +\n        '   fx=\"12.196308\"' +\n        '   fy=\"3.283603\"' +\n        '   r=\"7.5\" />'\n      );\n\n      var canvas = diagram.canvas = new DtdDiagram.Box(\n        -min_canvas_height / 2,\n        0,\n        min_canvas_height / 2,\n        min_canvas_width\n      );\n\n      svg.attr({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        xlink: \"http://www.w3.org/1999/xlink\",\n        \"width\": canvas.width(),\n        \"height\": canvas.height(),\n      });\n      diagram.svg_g = svg.append(\"g\")\n        .attr({\"transform\": \"translate(0, \" + (-canvas.top) + \")\"});\n\n      // Create the flextree layout engine and set options\n      var engine = diagram.engine = d3.layout.flextree()\n        .nodeSize(function(d) {\n          return [DtdDiagram.Node.node_height, d.y_size()];\n        })\n        .separation(function(a, b) {\n          var sep = a.elem_parent == b.elem_parent\n            ? 1 : diagram.group_separation\n          return sep;\n        })\n      ;\n\n      // Construct a new diagonal generator. `diagonal` is a function that\n      // draws the lines between the boxes.\n      // See https://github.com/mbostock/d3/wiki/SVG-Shapes#diagonal.\n      var diagonal = diagram.diagonal = d3.svg.diagonal()\n        .source(function(d, i) {\n          var s = d.source;\n          var t = d.target;\n          return {\n            x: s.x +\n              ( s.has_content() && d.target.type == \"attribute\" ? -6 :\n                s.has_attributes() && d.target.type != \"attribute\" ? 6 : 0),\n            y: s.y + s.width()\n          };\n        })\n        .projection(function(d) {\n          return [d.y, d.x];\n        })\n      ;\n\n      // Read the input file, and return the promise\n      return new Promise(function(resolve, reject) {\n        var dtd_json_file = diagram.dtd_json_file;\n        d3.json(dtd_json_file, function(error, dtd_json) {\n          if (error) {\n            reject(new Error(\"Error reading DTD file '\" + dtd_json_file +\n                \"': \" + error.statusText));\n          }\n          else {\n            diagram.dtd_json = dtd_json;\n\n            // Create the new tree.\n            try {\n              diagram.make_tree();\n              resolve();\n            }\n            catch(e) {\n              reject(e);\n            }\n          }\n        });\n      });\n    };\n\n    // This creates the orig_root_node from the orig_root_name, for a new tree of\n    // nodes, and then initializes the whole thing, based on the diagram's\n    // state properties.\n    DtdDiagram.prototype.make_tree = function() {\n      var diagram = this,\n          name = diagram.orig_root_name;\n\n      if (name) {\n        if (!diagram.dtd_json.elements[name]) {\n          diagram.orig_root_name = null;\n          throw new Error(\"Can't find a declaration for element \" + name +\n            \" in the DTD.\");\n        }\n      }\n      else {\n        name = diagram.orig_root_name = diagram.dtd_json.root;\n      }\n\n      var node = diagram.orig_root_node = DtdDiagram.Node.factory(diagram, {\n        name: name,\n        type: 'element',\n      }, null, \"0\");\n\n      // Expand everything as needed\n      if (!diagram.current_root_addr) {\n        diagram.current_root_addr = \"0\";\n      }\n\n      // Instantiate nodes up to the current_root\n      diagram.set_current_root();\n      // Set ec_state from current_root\n      diagram.set_ec_state();\n      // Set the src_node property from its address\n      diagram.set_src_node();\n      // Update the history state object\n      //diagram.update_state();\n    };\n\n\n    // Utility function to create a Promise out of a D3 transition. The\n    // Promise is resolved when all of the selection's transitions have\n    // ended. This was adapted from the code in this mailing list answer:\n    // https://groups.google.com/d/msg/d3-js/WC_7Xi6VV50/j1HK0vIWI-EJ\n    var transition_promise = DtdDiagram.transition_promise = function(t) {\n      var n = 0;\n      return new Promise(function(resolve, reject) {\n        if (t.empty()) resolve();\n        else {\n          t.each(function() { ++n; })\n            .each(\"end\", function() {\n              if (!--n) resolve();\n            })\n          ;\n        }\n      });\n    }\n\n    // Rebase the diagram with a new root. The argument specifies the new\n    // current root, either as an ElementNode object, or an addr string\n    DtdDiagram.prototype.rebase = function(n) {\n      var diagram = this;\n      diagram.set_current_root(n);\n      n.redraw = true;\n      n.q = null;\n      this.update(n, true);\n    };\n\n    // Main function to update the rendering. This is called once at the\n    // beginning, and once every time a user clicks a button on a node.\n    // `src_node` is the node object that was clicked; if it's not provided,\n    // then the diagram's current src_node is used.\n    // push, if true, means we should push a new state.\n    DtdDiagram.prototype.update = function(src_node, push) {\n      var diagram = this;\n      if (src_node) diagram.set_src_node(src_node);\n      src_node = diagram.src_node;\n\n      if (typeof push != \"undefined\" && push)\n        diagram.push_state();\n\n      // Keep a list of all promises (lest we forget)\n      var promises = [];\n\n      // Nodes\n      // -----\n\n      // Compute the new tree layout\n      var engine = diagram.engine;\n      var nodes = engine.nodes(diagram.current_root_node);\n\n      // Instantiate the SVG <g> for each entering node, and set\n      // the nodes_update, nodes_enter, and nodes_exit selections\n      DtdDiagram.Node.start_update(diagram, nodes);\n\n      // Draw each new, entering node\n      diagram.nodes_enter.each(function(n) {\n        n.draw_enter(this);\n      });\n\n      // Transition all nodes to their new positions and full sizes\n      diagram.nodes_update.each(function(n) {\n        promises.push(n.transition_update());\n      });\n\n      // Transition exiting nodes to the parent's new position, and\n      // zero size.\n      diagram.nodes_exit.each(function(n) {\n        promises.push(n.transition_exit());\n      });\n\n\n      // Links (diagonals)\n      // -----------------\n\n      var links = engine.links(nodes);\n\n      // Bind the links to the SVG paths\n      var links_selection = diagram.svg_g.selectAll(\"path.link\")\n        .data(links, function(d) { return d.target.id; });\n\n      // Enter any new links at the parent's previous position.\n      var fake_node = {\n        x: src_node.x0,\n        y: src_node.y0,\n        width: function() { return 0; },\n        has_content: function() { return false; },\n        has_attributes: function() { return false; },\n      };\n      var diagonal = diagram.diagonal;\n      links_selection.enter().insert(\"path\", \"g\")\n        .attr(\"class\", \"link\")\n        .attr(\"d\", function(d) {\n          return diagonal({source: fake_node, target: fake_node});\n        });\n\n      // Transition links to their new position.\n      var duration = diagram.duration;\n      promises.push(transition_promise(\n        links_selection.transition()\n          .duration(duration)\n          .attr(\"d\", diagonal)\n      ));\n\n      // Transition exiting links to the parent's new positions.\n      promises.push(transition_promise(\n        links_selection.exit().transition()\n          .duration(duration)\n          .attr(\"d\", function(d) {\n            return diagonal({source: fake_node, target: fake_node});\n          })\n          .remove()\n      ));\n\n\n      // Canvas / scrollbars\n      // -------------------\n\n      // Transition scrollbars and drawing size\n      var Canvas = DtdDiagram.Canvas;\n      promises.push(DtdDiagram.Canvas.scroll_resize(diagram));\n      diagram.canvas = diagram.new_canvas.copy();\n\n      Promise.all(promises).then(\n        function(msg) {\n          //console.log(\"Transitions complete: \" + msg);\n          Canvas.finish(diagram);\n        },\n        function(msg) {\n          console.error(\"Problem during transistions: \" + msg.stack);\n        }\n      );\n\n      // Stash the old positions for transition.\n      nodes.forEach(function(d) {\n        d.x0 = d.x;\n        d.y0 = d.y;\n      });\n    };\n\n\n    // Simple extend utility function\n    DtdDiagram.extend = function() {\n      var target = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var obj = arguments[i];\n        for (var key in obj)\n          if (obj.hasOwnProperty(key)) target[key] = obj[key];\n      }\n      return target;\n    };\n\n\n  })();\n}","// DtdDiagram.Box class.\n// Holds coordinates for top, left, bottom, and right. Has methods for\n// moving the box, vertically or horizontally.\n\n(function() {\n\n  var Box = DtdDiagram.Box = function(top, left, bottom, right) {\n    this.top = top;\n    this.left = left;\n    this.bottom = bottom;\n    this.right = right;\n  }\n\n  // Object methods\n  DtdDiagram.extend(\n    Box.prototype, \n    {\n      log: function(name) {\n        console.log(name + \": {top: \" + this.top + \", left: \" + this.left + \n          \", bottom: \" + this.bottom + \", right: \" + this.right + \"}\");\n      },\n      copy: function() {\n        return new Box(this.top, this.left, this.bottom, this.right);\n      },\n      width: function() {\n        return this.right - this.left;\n      },\n      height: function() {\n        return this.bottom - this.top;\n      },\n      vcenter: function() {\n        return (this.top + this.bottom) / 2;\n      },\n      vmove: function(d) {\n        this.top += d;\n        this.bottom += d;\n        return this;\n      },\n      hmove: function(d) {\n        this.left += d;\n        this.right += d;\n        return this;\n      },\n    }\n  );\n})();\n","// DtdDiagram.Node class\n\n(function() {\n\n  var Node = DtdDiagram.Node = {\n    // Some constants used in drawing\n    node_height: 32,\n    node_box_height: 25,\n    diagonal_width: 20,\n    node_text_margin: 10,\n  };\n\n  // Registry of subclass constructors\n  var subclasses = {};\n  Node.register = function(type, cls) {\n    subclasses[type] = cls;\n  }\n\n  // The factory constructs a Node from a specification within a content section\n  // of some element within the DTD. This uses the type registry to call the \n  // subclass constructors.\n\n  Node.factory = function(diagram, spec, elem_parent, id) {\n    if (!spec.type) {\n      console.error(\"Invalid DTD, every node specifier must have a type\");\n      return null;\n    }\n    var subclass = subclasses[spec.type];\n    if (!subclass) {\n      console.error(\"Invalid DTD, node type not recognized: \" + spec.type);\n      return null;\n    }\n\n    var n = new subclass();\n    n.id = id;\n    n.x0 = elem_parent ? elem_parent.x0 : 0;\n    n.y0 = elem_parent ? elem_parent.y0 : 0;\n\n    // Copy *name*, *type*, and *q*, but not *children*.\n    n.diagram = diagram;\n    n.spec = spec;\n    n.elem_parent = elem_parent;\n    n.children = [];\n    for (var k in spec) {\n      if (k != \"children\") {\n        n[k] = spec[k];\n      }\n    }\n\n    n.initialize();\n    if (typeof diagram.nodes == \"undefined\") diagram.nodes = {};\n    diagram.nodes[id] = n;\n    \n    return n;\n  };\n\n  // Some functions to help draw SVG paths\n  Node.path = function() {\n    var p = \"\";\n    for (var i = 0; i < arguments.length; ++i) {\n      p += arguments[i] + \" \";\n    }\n    return p;\n  }\n  // lineto by distance and angle\n  Node.la = function(d, a) {\n    return \"l \" + (d * Math.cos(a)) + \",\" + (d * Math.sin(a)) + \" \";\n  };\n  // circular arc, always drawn clockwise\n  Node.arc = function(r, x, y, large_arc) {\n    if (typeof large_arc == \"undefined\") large_arc = 0;\n    return \"a \" + r + \",\" + r + \" 0,\" + large_arc + \",1 \" + x + \",\" + y + \" \";\n  };\n\n  // Start the update, after the user has clicked on a button. First thing is\n  // to bind the data - the list of Node\n  // objects in the tree bound to their `g.node` SVG elements;\n  // then create update, enter, and exit selections and store\n  // those in diagram.\n  Node.start_update = function(diagram, nodes) {\n    var src_node = diagram.src_node;\n\n    var nodes_update = diagram.nodes_update = \n      diagram.svg_g.selectAll(\"g.node\")\n        .data(nodes, function(d) { \n          return d.id; \n        })\n      ;\n\n    // The x,y location <g> of entering nodes all start the animation\n    // at the src_node\n    var nodes_enter = diagram.nodes_enter = \n      nodes_update.enter().append(\"g\")\n        .attr({\n          \"class\": function(d) {\n            return \"node \" + d.type;\n          },\n          filter: \"url(#dropshadow)\",\n          transform: \"translate(\" + src_node.y0 + \",\" + src_node.x0 + \") \" +\n                     \"scale(0.001, 0.001)\",\n        })\n      ;\n\n    // For entering Nodes, initialize gs, which is the D3 selection for\n    // the <g> container element\n    nodes_enter.each(function(d) {\n      d.gs = d3.select(this);\n    });\n\n    diagram.nodes_exit = nodes_update.exit();\n  };\n\n\n  // Some private utility functions\n\n  function merge_array(target, source) {\n    for (var i = 0; i < source.length; ++i) \n      target.push(source[i]);\n  }\n\n  // Tree-reduce function: returns the min/max extents\n  // of an accumulator (previous extents), a given node (n) and all\n  // of that node's kids.\n  function _tree_reduce(acc, n) {\n    //acc.log(\"_tree_reduce:acc\");\n    // kids extents\n    var ke = n.get_children().reduce(_tree_reduce, acc);  \n    var ne = n.extents();\n\n    return new DtdDiagram.Box(\n      d3.min([ke.top,    ne.top]),\n      d3.min([ke.left,   ne.left]),\n      d3.max([ke.bottom, ne.bottom]),\n      d3.max([ke.right,  ne.right])\n    );\n  }\n\n  ////////////////////////////////////////////////\n  // Object methods\n\n  Node.methods = {\n\n    initialize: function() {},\n\n    has_content: function() {\n      return false;\n    },\n\n    has_attributes: function() {\n      return false;\n    },\n\n    has_q: function() {\n      return false;\n    },\n\n    q_width: function() {\n      return 0;\n    },\n\n    // Returns an array of the current children of the Node, in the\n    // current state of the tree. If it has none, returns the empty array.\n    get_children: function() {\n      return this.children || [];\n    },\n\n    get_child: function(n) {\n      return this.get_children()[n];\n    },\n\n    // Returns an array of the content children of the Node. This will\n    // cause ElementNodes to be initialized - their children instantiated\n    // from the DTD spec.\n    get_content: function() {\n      return [];\n    },\n\n    // Get all the elements in this subtree, including self if this\n    // is an ElementNode. Does not expand anything - returns the list\n    // in the current state of the tree\n    element_list: function() {\n      return this.get_children().reduce(\n        function(prev, n) {\n          return prev.concat(n.element_list());\n        },\n        this.type == \"element\" ? [this] : []\n      );\n    },\n\n    // Get the state of this subtree, as a string of \"0\"s and \"1\"s.\n    state: function() {\n      return \"\" + this.state_children();\n    },\n\n    state_children: function() {\n      return this.get_children().reduce(\n        function(prev, n) { return prev + n.state(); }, \"\"\n      );\n    },\n\n    set_ec_state: function(b, bi) {\n      return this.set_state_children(b, bi);\n    },\n\n    set_state_children: function(b, bi) {\n      var kids = this.get_children();\n      for (var ki = 0; ki < kids.length; ++ki) {\n        bi = kids[ki].set_ec_state(b, bi);\n      }\n      return bi;\n    },\n\n\n    // Geometry / layout related\n    // -------------------------\n\n    extents: function() {\n      var diagram = this.diagram;\n      return new DtdDiagram.Box(\n        this.x - Node.node_box_height / 2,\n        this.y,\n        this.x + Node.node_box_height / 2,\n        this.y + this.width()\n      );\n    },\n\n    // Determine the extents of a (sub)tree, returning a Box object.\n    tree_extents: function() {\n      return this.get_children()\n        .reduce(_tree_reduce, this.extents());\n    },\n\n    // D3/SVG drawing\n    // --------------\n\n    // Get a Node's y_size, which is used by the layout engine. This is really\n    // it's total width (the d3.flextree layout uses x for vertical and y for\n    // horizontal).\n    y_size: function() {\n      return this.width() + Node.diagonal_width;\n    },\n\n    // The width of the node, not including the diagonal\n    width: function() {\n      return this.compute_width();\n    },\n\n    // Transition an (updating or entering) node to its new position and \n    // full-sized scale\n    transition_update: function() {\n      var self = this;\n      return DtdDiagram.transition_promise(\n        self.gs.transition()\n          .duration(self.diagram.duration)\n          .attr(\"transform\", \n            \"translate(\" + self.y + \",\" + self.x + \") \" +\n            \"scale(1, 1)\"\n          )\n      );\n    },\n\n    // Transition exiting nodes to their parents' positions and zero size,\n    // then remove them.\n    transition_exit: function() {\n      var self = this\n          src_node = self.diagram.src_node;\n\n      return DtdDiagram.transition_promise(\n        self.gs.transition()\n          .duration(self.diagram.duration)\n          .attr(\"transform\", function(d) { \n            return \"translate(\" + src_node.y + \",\" + src_node.x + \") \" +\n                   \"scale(0.001, 0.001)\"; \n          })\n          .remove()\n      );\n    },\n  };\n\n})();\n","// DtdDiagram.HasLabelNode mixin\n\n(function() {\n  var Node = DtdDiagram.Node;\n\n  // These methods are mixed in with the inheriting class' prototype\n  DtdDiagram.HasLabelNode = {\n\n    // Draw an entering label. \n    draw_enter_label: function() {\n      var self = this,\n          diagram = self.diagram;\n\n      var doc_url = diagram.tag_doc_url(self);\n\n      // Draw the text. If it's an attribute or element node, make\n      // it a hyperlink\n      var container = self.gs;\n      if (doc_url)\n        container = self.gs.append(\"a\")\n          .attr(\"xlink:href\", doc_url);\n\n      container.append(\"text\")\n        .attr({\n          id: self.id,\n          \"class\": \"label\",\n          x: Node.node_text_margin + self.q_width(),\n          y: 0,\n          \"text-anchor\": \"baseline\",\n          \"alignment-baseline\": \"middle\",\n        })\n        .text(self.name)\n      ;\n    },\n\n    // Get the displayed width for a label string. This generates a temporary\n    // SVG text node, measures its width, and then destroys it. It caches\n    // the results in diagram.label_width_cache.\n    // Return value includes 2*node_text_margin.\n    label_width: function() {\n      var self = this,\n          diagram = self.diagram,\n          label = self.name;\n\n      if (!(\"label_width_cache\" in diagram)) {\n        diagram.label_width_cache = {};\n      }\n      var cache = diagram.label_width_cache;\n      if (!(label in cache)) {\n        var text = diagram.svg_g\n          .append(\"text\")\n            .attr({\n              \"id\": \"temporary-label\",\n              \"class\": \"label\",\n              x: 0,\n              y: 0,\n            })\n            .text(label)\n            .style(\"fill-opacity\", 0)\n        ;\n        cache[label] = 2 * Node.node_text_margin +\n          document.getElementById(\"temporary-label\").getBBox()[\"width\"];\n        text.remove();\n      }\n      return cache[label];\n    },\n\n    compute_width: function() {\n        return this.label_width();\n    },\n  };\n})();\n","// DtdDiagram.HasQNode mixin\n\n(function() {\n  var Node = DtdDiagram.Node,\n      path = Node.path,\n      arc = Node.arc,\n      la = Node.la,\n      arca = Node.arca,\n      q_width = 12;\n\n  // plus sign\n  var s = 4,\n      plus = path(\"M\", -s, 0, \"l\", 2*s, 0, \"M\", 0, -s, \"l\", 0, 2*s);\n\n  // asterisk\n  var h = 4.5,\n      asterisk = (function() {\n        var a = -Math.PI / 2;\n        var p = '';\n        for (var i = 0; i < 5; ++i) {\n          p += path(\"M\", 0, 0) + la(h, a + i * 2 * Math.PI / 5);\n        }\n        return p;\n      })();\n\n  // question\n  var r = 2.3,\n      a = Math.PI / 3,\n      sx = -r * Math.sin(a),\n      sy = -r * (1 + Math.cos(a)),\n      d = 2,\n      p = 4,\n      question = path(\"M\", sx, sy) + arc(r, -sx, -sy, 1) + path(\"l\", 0, d) +\n                 \"m 0,3 \" + arc(.5, 0.0001, 0, 1) + \"z\";\n\n\n  // These methods are mixed in with the inheriting class' prototype\n  DtdDiagram.HasQNode = {\n    initialize: function() {\n      if (!(\"q\" in this)) this.q = null;\n    },\n\n    has_q: function() {\n      return !!this.q;\n    },\n\n    // Width of the `q` label, if there is one, or zero, if not\n    q_width: function() {\n      return this.has_q() ? q_width : 0;\n    },\n\n    // Draw the text label for `q`\n    draw_enter_q: function(offset_x) {\n      var self = this;\n      if (!self.has_q()) return;\n\n      var q = self.q,\n          path = q == \"*\" ? asterisk :\n                 q == \"+\" ? plus :\n                 question;\n      self.gs.append(\"g\")\n        .attr(\"transform\", \"translate(\" + offset_x + \",0)\")\n        .append(\"path\")\n          .attr({\n            'class': 'q',\n            'd': path,\n          })\n      ;\n    },\n  };\n})();\n","// DtdDiagram.ElementNode class\n\n(function() {\n  var Node = DtdDiagram.Node,\n      HasLabelNode = DtdDiagram.HasLabelNode,\n      HasQNode = DtdDiagram.HasQNode,\n      button_width = 15;\n\n  // Constructor.\n  var ElementNode = DtdDiagram.ElementNode = function() {};\n\n  // Register this type\n  Node.register(\"element\", ElementNode);\n\n  // Class methods\n\n  ElementNode.content_click_handler = function(n) {\n    n.toggle_content();\n    n.diagram.update(n, true);\n    if (typeof n.diagram.event_handler == \"function\")\n      n.diagram.event_handler(\"content-click\", n);\n  };\n\n  ElementNode.attributes_click_handler = function(n) {\n    n.toggle_attributes();\n    n.diagram.update(n, true);\n    if (typeof n.diagram.event_handler == \"function\")\n      n.diagram.event_handler(\"attributes-click\", n);\n  };\n\n  ElementNode.rebase_click_handler = function(n) {    \n    // If it's totally collapsed, go ahead and expand it\n    if (!n.content_expanded && !n.attributes_expanded) {\n      n.expand_content();\n    }\n    n.diagram.rebase(n);\n    if (typeof n.diagram.event_handler == \"function\")\n      n.diagram.event_handler(\"rebase\", n);\n  }\n\n  // Object methods\n\n  DtdDiagram.extend(\n    ElementNode.prototype, \n    Node.methods,\n    HasLabelNode,\n    HasQNode,\n    {\n      initialize: function() {\n        var self = this,\n            diagram = self.diagram;\n        HasQNode.initialize.call(self);\n\n        self.content = null;\n        self.content_expanded = false;\n        self.attributes_expanded = false;\n\n        // Initialize attributes now\n        var decl = self.declaration = diagram.dtd_json.elements[self.name];\n        if (typeof decl != \"object\") {\n          console.error(\"Can't find a declaration for element \" + self.name +\n            \" in the DTD.\");\n          decl = self.declaration = null;\n        }\n        var attrs = self.attributes = [];\n        var kid_num = 0;\n        if (decl && decl.attributes) {\n          decl.attributes.forEach(function(attr_spec) {\n            attrs.push(Node.factory(diagram, attr_spec, self, \n                                    self.id + \",\" + kid_num++));\n          });\n        }\n      },\n\n      // Called the first time we need to discover the content children\n      // for an ElementNode.\n      init_content: function() {\n        var self = this,\n            diagram = self.diagram,\n            decl = self.declaration;\n\n        var content = self.content = [];\n        var kid_num = self.attributes.length;\n        if (decl && decl.content && decl.content.children) {\n          decl.content.children.forEach(function(kid_spec) {\n            content.push(Node.factory(diagram, kid_spec, self,\n                                      self.id + \",\" + kid_num++));\n          });\n        }\n      },\n\n      // Get the array of content children (as opposed to attribute children)\n      // or the empty array, if there are none. Causes children to be\n      // instantiated from the dtd spec, if they haven't been before.\n      get_content: function() {\n        if (this.content == null) this.init_content();\n        return this.content;\n      },\n\n      // Returns true if there are any content children \n      // (as opposed to attributes). Causes children to be instantiated,\n      // if they haven't been before.\n      has_content: function() {\n        if (this.content == null) this.init_content();\n        return this.content.length > 0;\n      },\n\n      // Returns true if this Node has any attribute children.\n      has_attributes: function() {\n        return this.attributes.length > 0;\n      },\n\n      // Event handlers\n      // --------------\n\n      toggle_content: function() {\n        this.content_expanded = !this.content_expanded;\n        this.set_children();\n      },\n\n      collapse_content: function() {\n        this.content_expanded = false;\n        this.set_children();\n      },\n\n      expand_content: function() {\n        this.content_expanded = true;\n        this.set_children();\n      },\n\n      toggle_attributes: function() {\n        this.attributes_expanded = !this.attributes_expanded;\n        this.set_children();\n      },\n\n      collapse_attributes: function() {\n        this.attributes_expanded = false;\n        this.set_children();\n      },\n      \n      expand_attributes: function() {\n        this.attributes_expanded = true;\n        this.set_children();\n      },\n\n      expand: function() {\n        this.content_expanded = this.attributes_expanded = true;\n        this.set_children();\n      },\n\n      set_children: function() {\n        var cexp = this.content_expanded,\n            aexp = this.attributes_expanded;\n\n        if (!cexp && !aexp) {\n          this.children = [];\n        }\n        else if (!cexp && aexp) {\n          this.children = this.attributes;\n        }\n        else if (cexp && !aexp) {\n          this.children = this.get_content();\n        }\n        else {\n          this.children = this.attributes.concat(this.get_content());\n        }\n\n        if (this.gs) {\n          this.gs.select('.cb rect').attr(\"class\", \n            cexp ? \"expanded\" : \"collapsed\");\n          this.gs.select('.ab rect').attr(\"class\", \n            aexp ? \"expanded\" : \"collapsed\");\n        }\n      },\n\n      // Get the nth child, according to the address value. It might be an\n      // attribute or a content child\n      get_child: function(n) {\n        var alen = this.attributes.length;\n        if (n < alen) return this.attributes[n];\n        return this.get_content()[n - alen];\n      },\n\n      // Drawing\n      // -------\n\n      compute_width: function() {\n        return this.q_width() +\n            (this.has_content() || this.has_attributes() \n              ? button_width : 0) +\n            this.label_width();\n      },\n\n      // Draw the initial state of the node box, label, etc.\n      draw_enter: function() {\n        var self = this,\n            diagram = self.diagram,\n            gs = self.gs,\n            node_box_height = Node.node_box_height;\n\n        // Draw the box.\n        gs.append(\"rect\")\n          .attr({\n            \"data-id\": self.id,\n            \"class\": \"box\",\n            width: self.width(),\n            height: node_box_height,\n            y: -node_box_height / 2,\n            rx: 6,\n            ry: 6,\n          })\n        ;\n\n        self.draw_enter_label();\n        self.draw_enter_q(Node.node_text_margin);\n\n        // content expand button\n        if (self.has_content()) {\n          self.draw_button(\"cb\",\n            self.has_attributes() ? node_box_height / 4 - 0.5 : 0,\n            ElementNode.content_click_handler);\n        }\n\n        // attributes expand button\n        if (self.has_attributes()) {\n          self.draw_button(\"ab\",\n            self.has_content() ? -node_box_height / 4 + 0.5 : 0,\n            ElementNode.attributes_click_handler);\n        }\n\n        // rebase button\n        var button_g = gs.append(\"g\")\n          .attr({\n            \"class\": \"button rebase\",\n            \"transform\": \"translate(2, -16)\",\n          });\n        button_g.append(\"rect\")\n          .attr({\n            'class': \"collapsed\",\n            width: 10,\n            height: 5,\n            x: 0,\n            y: 0,\n            rx: 2.5,\n            ry: 2.5,\n            transform: \"translate(0,5)\",\n          })\n          .on('click', ElementNode.rebase_click_handler);\n      },\n\n      // Helper to draw a single content or attributes expander button\n      // `button_type` is either \"cb\" or \"ab\".\n      draw_button: function(button_type, y, handler) {\n        var self = this,\n            diagram = self.diagram,\n            gs = self.gs,\n            node_box_height = Node.node_box_height,\n            width = self.width();\n\n        var button_g = gs.append(\"g\")\n          .attr({\n            \"class\": \"button \" + button_type,\n            \"transform\": \"translate(\" + (width - button_width - 2) + \n                         \",\" + (y + node_box_height / 4 - 16.2) + \")\",\n          });\n\n        var expanded = button_type == 'cb' ?\n          self.content_expanded : self.attributes_expanded;\n        var cls = expanded ? \"expanded\" : \"collapsed\";\n        button_g.append(\"rect\")\n          .attr({\n            'class': cls,\n            width: 15,\n            height: 10,\n            x: 0,\n            y: 0,\n            rx: 5,\n            ry: 5,\n            transform: \"translate(0,5)\",\n          })\n          .on('click', handler);\n\n        // Draw the button label - either \"< >\" or \"@\"\n        if (button_type == \"cb\") {\n          button_g.append('g')\n            .attr(\"transform\", \"translate(-0.56249982,0)\")\n            .attr(\"pointer-events\", \"none\")\n            .html(\n              '<g transform=\"matrix(0.93056698,0,0,1.2232143,-0.79346636,-1.1542969)\">' +\n              '  <path d=\"m 2.5245,8.71325 6.076,-2.842 0,1.022 -4.97,2.268 4.956,2.268 0.014,1.022 -6.076,-2.842 0,-0.896\" />' +\n              '</g>' +\n              '<g transform=\"matrix(-0.93056698,0,0,1.2232143,16.918466,-1.1542969)\">' +\n              '  <path d=\"m 2.5245,8.71325 6.076,-2.842 0,1.022 -4.97,2.268 4.956,2.268 0.014,1.022 -6.076,-2.842 0,-0.896\"/>' +\n              '</g>'\n            );\n        }\n        else {\n          button_g.append('path')\n            .attr(\"pointer-events\", \"none\")\n            .attr('d', \"m 8.136125,11.77975 c -5.6e-6,-0.07466 0.00466,-0.139997 0.014,-0.196 -0.3546719,0.550669 -0.9006713,0.826002 -1.638,0.826 -0.4480035,2e-6 -0.8120031,-0.149331 -1.092,-0.448 -0.2706692,-0.307997 -0.4060024,-0.704663 -0.406,-1.19 -2.4e-6,-0.8493287 0.3079973,-1.5959946 0.924,-2.24 0.615996,-0.6533266 1.3299953,-0.979993 2.142,-0.98 0.186661,7e-6 0.3919941,0.028007 0.616,0.084 l 0.28,0.07 c 0.037327,0.018674 0.083994,0.028007 0.14,0.028 0.04666,6.9e-6 0.1259933,-0.023326 0.238,-0.07 0.1493264,-0.065326 0.2566596,-0.097993 0.322,-0.098 0.1399928,7e-6 0.2099927,0.060674 0.21,0.182 -7.3e-6,0.028007 -0.00934,0.07934 -0.028,0.154 l -0.07,0.266 -0.798,2.982 c -0.028006,0.112003 -0.042006,0.20067 -0.042,0.266 -6.4e-6,0.168003 0.08866,0.252003 0.266,0.252 0.3453264,3e-6 0.667326,-0.223997 0.966,-0.672 0.419992,-0.625329 0.629992,-1.3486617 0.63,-2.17 -8e-6,-0.7746601 -0.256675,-1.4186595 -0.77,-1.932 -0.504007,-0.5133251 -1.1433397,-0.7699915 -1.918,-0.77 -1.0920045,8.5e-6 -2.0440035,0.4386747 -2.856,1.316 -0.8026686,0.8680063 -1.2040015,1.8900053 -1.204,3.066 -1.5e-6,0.91467 0.2939982,1.680002 0.882,2.296 0.587997,0.606668 1.3253296,0.910001 2.212,0.91 0.5226616,10e-7 0.9519945,-0.06067 1.288,-0.182 0.3453271,-0.130665 0.77466,-0.382665 1.288,-0.756 0.1866593,-0.139998 0.340659,-0.209998 0.462,-0.21 0.177326,2e-6 0.265992,0.084 0.266,0.252 -8e-6,0.177335 -0.121341,0.359335 -0.364,0.546 -0.9240066,0.728001 -1.9413389,1.092 -3.052,1.092 -1.1293367,0 -2.0720024,-0.373333 -2.828,-1.12 -0.7466676,-0.755998 -1.1200005,-1.698664 -1.12,-2.828 -5e-7,-1.3626612 0.503999,-2.5479934 1.512,-3.556 1.0173303,-1.0173247 2.2166624,-1.5259908 3.598,-1.526 1.0453267,9.2e-6 1.894659,0.3080089 2.548,0.924 0.662658,0.6160076 0.993991,1.4186735 0.994,2.408 -9e-6,1.1106714 -0.406009,2.081337 -1.218,2.912 -0.494674,0.504002 -1.0126736,0.756002 -1.554,0.756 -0.2426728,2e-6 -0.4433393,-0.06066 -0.602,-0.182 -0.1586723,-0.121331 -0.2380056,-0.275331 -0.238,-0.462 m 0.294,-1.904 0.378,-1.4 c -0.2800059,-0.1399937 -0.5506723,-0.2099937 -0.812,-0.21 -0.5413382,6.3e-6 -1.0173377,0.2380061 -1.428,0.714 -0.4013369,0.4760051 -0.6020034,1.031338 -0.602,1.666 -3.4e-6,0.644003 0.2799963,0.966003 0.84,0.966 0.7746617,3e-6 1.3159945,-0.578663 1.624,-1.736\")\n        }\n      },\n\n      // Override the update transition function here, because in the case\n      // where we're rebasing, the `q` gets deleted, and we need to redraw\n      // the button\n      transition_update: function() {\n        if (this.redraw) {\n          this.gs.html(\"\");\n          this.draw_enter();\n          this.redraw = false;\n        }\n        Node.methods.transition_update.call(this);\n      },\n\n      // The state of this ElementNode, as a string of three \"0\"s \n      // and \"1\"s. \n      state: function() {\n        return (this.attributes_expanded ? \"1\" : \"0\") +\n               (this.content_expanded ? \"1\" : \"0\") +\n               this.state_children();\n      },\n\n      // Set the expand/collapse state of this node and all it's children.\n      // Returns the new bi index value\n      set_ec_state: function(b, bi) {\n        if (typeof bi == \"undefined\") bi = 0;\n        this.attributes_expanded = (b.charAt(bi) == \"1\");\n        this.content_expanded = (b.charAt(bi+1) == \"1\");\n        //console.log(\"setting state of \" + this.name + \" to \" + \n        //  this.attributes_expanded + \", \" + this.content_expanded);\n        this.set_children();\n        return this.set_state_children(b, bi+2);\n      },\n    }\n  );\n})();\n","// DtdDiagram.AttributeNode class\n\n(function() {\n  var Node = DtdDiagram.Node,\n      attribute_box_height = 21;\n\n  // Constructor\n  var AttributeNode = DtdDiagram.AttributeNode = function() {};\n\n  // Register this type\n  Node.register(\"attribute\", AttributeNode);\n\n  // Object methods\n  DtdDiagram.extend(\n    AttributeNode.prototype, \n    Node.methods,\n    DtdDiagram.HasLabelNode,\n    {\n      draw_enter: function() {\n        var self = this;\n\n        // Draw the box.\n        self.gs.append(\"ellipse\")\n          .attr({\n            \"data-id\": self.id,\n            \"class\": \"box\",\n            cx: self.width() / 2,\n            cy: 0,\n            rx: self.width() / 2,\n            ry: attribute_box_height / 2,\n          })\n        ;\n        self.draw_enter_label();\n      },\n    }\n  );\n})();\n","// DtdDiagram.ChoiceSeqNode mixin.\n\n(function() {\n\n  // Object methods\n  DtdDiagram.ChoiceSeqNode = {\n    initialize: function() {\n      var self = this;\n      DtdDiagram.HasQNode.initialize.call(self);\n      var kid_num = 0;\n      (self.spec.children || []).forEach(function(kid_spec) {\n        self.children.push(\n          DtdDiagram.Node.factory(self.diagram, kid_spec, self.elem_parent,\n                                  self.id + \",\" + kid_num++));\n      });\n    },\n\n    get_content: function() {\n      return this.get_children();\n    },\n\n    // Draw entering nodes\n    draw_enter: function() {\n      this.gs.append(\"path\")\n        .attr({\n          'class': this.type,\n          'd': this.path(),\n        })\n      ;\n      this.draw_enter_q(this.width()/2);\n    },\n  };\n\n})();\n","// DtdDiagram.ChoiceNode class\n\n(function() {\n  var Node = DtdDiagram.Node,\n      width = 20;\n\n  var ChoiceNode = DtdDiagram.ChoiceNode = function() {};\n  Node.register(\"choice\", ChoiceNode);\n\n  // Object methods\n  DtdDiagram.extend(\n    ChoiceNode.prototype, \n    Node.methods,\n    DtdDiagram.HasQNode,\n    DtdDiagram.ChoiceSeqNode,\n    {\n      width: function() { return width; },\n\n      path: function() {        \n        return Node.path(\"M\", 0, 0, \"L\", width/2, -width/2, \"L\", width, 0, \"L\", \n                         width/2, width/2, \"z\")\n      },\n    }\n  );\n\n})();\n","// DtdDiagram.SeqNode class\n\n(function() {\n  var Node = DtdDiagram.Node,\n      width = 13;\n\n\n  var SeqNode = DtdDiagram.SeqNode = function() {};\n  Node.register(\"seq\", SeqNode);\n\n  // Object methods\n  DtdDiagram.extend(\n    SeqNode.prototype, \n    Node.methods,\n    DtdDiagram.HasQNode,\n    DtdDiagram.ChoiceSeqNode,\n    {\n      width: function() {\n        return width;\n      },\n\n      path: function() {\n        var path = Node.path\n            arc = Node.arc,\n            s = 8;\n        return path(\"M\", 0, s/2, \"v\", -s) +\n               arc(width/2, width, 0) +\n               path(\"v\", s) + \n               arc(width/2, -width, 0) + \"z\";\n      },\n    }\n  );\n})();\n","// DtdDiagram.OtherNode class\n\n(function() {\n  var Node = DtdDiagram.Node,\n      other_box_height = 18;\n\n  // Constructor\n  var OtherNode = DtdDiagram.OtherNode = function() {};\n\n  // Register this type\n  Node.register(\"other\", OtherNode);\n\n  // Object methods\n  DtdDiagram.extend(\n    OtherNode.prototype, \n    Node.methods,\n    DtdDiagram.HasLabelNode,\n    {\n      draw_enter: function() {\n        var self = this;\n\n        // Draw the box.\n        self.gs.append(\"g\")\n          .attr(\"transform\", \"skewX(-15)\")\n          .append(\"rect\")\n            .attr({\n              \"data-id\": self.id,\n              \"class\": \"box\",\n              width: self.width(),\n              height: other_box_height,\n              y: - other_box_height / 2,\n              rx: 3,\n              ry: 3,\n            })\n        ;\n        self.draw_enter_label();\n      },\n    }\n  );\n})();\n","// DtdDiagram.Canvas class\n// The main class method, scroll_resize, handles resizing the\n// main drawing object and scrolling the viewport.\n\n// To do auto-resizing and auto-scrolling, here is the algorithm:\n// - find the new drawing size\n// - figure out the new size of the canvas (not always the same)\n// - compute the \"cover box\", which is the smallest box that the viewport\n//   should cover in the new layout\n// - find out where the viewport is now\n// - figure where to move the viewport to -- move it the smallest amount that \n//   will cause it to be over the cover box.\n\n(function() {\n\n  var Canvas = DtdDiagram.Canvas = {\n    // Constants\n    dropshadow_margin: 5,\n  };\n\n\n\n  // The main function of this module. It takes the diagram as an argument,\n  // computes everything, kicks off the transformation.\n  // This returns a Promise.  The \"do_last\" attribute of the returned object,\n  // if defined, is a function that should be called when all other animations are\n  // resolved.\n  Canvas.scroll_resize = function(diagram) {\n    compute_new_canvas(diagram);\n\n    return Promise.all([\n      // Scroll the canvas\n      scroll_canvas(diagram),\n      // At the same time, transition the svg coordinates\n      new Promise(function(resolve, reject) {\n        diagram.svg_g.transition()\n          .duration(diagram.duration)\n          .attr({\"transform\": \"translate(0, \" + (-diagram.new_canvas.top) + \")\"})\n          .each(\"end\", function() {\n            resolve(\"done transitioning svg coordinates\");\n          });\n      })\n    ]);\n  }\n\n  // If the drawing is getting smaller, we resize the canvas at the end\n  Canvas.finish = function(diagram) {\n    if (!diagram.embiggenning) resize_canvas(diagram);\n  }\n\n  // Compute the new parameters for the new canvas and viewport\n  var compute_new_canvas = function(diagram) {\n    // Some local-variable shortcuts\n    var Box = DtdDiagram.Box,\n        min_canvas_height = diagram.min_canvas_height,\n        min_canvas_width = diagram.min_canvas_width,\n        src_node = diagram.src_node,\n        canvas = diagram.canvas;\n\n    // Determine the new extents of the whole drawing -- this is a Box object.\n    var new_drawing = diagram.new_drawing = diagram.current_root_node.tree_extents();\n    new_drawing.bottom += Canvas.dropshadow_margin;\n    //new_drawing.log(\"new_drawing\");\n\n    // From that, determine the new dimensions of the svg canvas\n    var nc_top = new_drawing.height() >= min_canvas_height ?\n        new_drawing.top :\n        (new_drawing.bottom + new_drawing.top - min_canvas_height) / 2;\n    var nc_bottom = new_drawing.height() >= min_canvas_height ?\n        new_drawing.bottom :\n        nc_top + min_canvas_height;\n    var new_canvas = diagram.new_canvas = new Box(\n        nc_top, \n        new_drawing.left,\n        nc_bottom,\n        new_drawing.width() >= min_canvas_width ?\n          new_drawing.right :\n          new_drawing.left + min_canvas_width\n    );\n    //new_canvas.log(\"new_canvas\");\n\n    // Get the extents of the src_node (the node the user clicked on) \n    // and its subtree.\n    var src_node_extents = src_node.extents();\n    var stree_extents = src_node.tree_extents();\n    //stree_extents.log(\"stree_extents\");\n\n    // Compute the box that the viewport needs to cover. This will:\n    // - fit entirely inside the viewport\n    // - contain the src_node node\n    // - subject to those constraints, cover as much of the stree as possible\n    var cover_box = stree_extents.copy();\n\n    // If it's too wide, then move the right edge over, so that the \n    // the src_node node is in the viewport, and the width is correct\n    if (cover_box.width() > min_canvas_width) {\n      cover_box.right = cover_box.left + min_canvas_width;\n    }\n\n    // If it's too tall, then center the cover_box vertically, with the\n    // constraint that the src_node is in the viewport\n    if (cover_box.height() > min_canvas_height) {\n      // Find what the top and bottom would be, with the viewport centered\n      var vcenter = cover_box.vcenter();\n      var want_top = vcenter - min_canvas_height / 2;\n      var want_bottom = vcenter + min_canvas_height / 2;\n      // Make sure the src_node node is contained\n      var nudge =\n          src_node_extents.top < want_top ? src_node_extents.top - want_top :\n          src_node_extents.bottom > want_bottom ? src_node_extents.bottom - want_bottom :\n          0;\n      cover_box.top = want_top + nudge;\n      cover_box.bottom = want_bottom + nudge;\n    }\n    //cover_box.log(\"cover_box\");\n\n    // Where is the viewport now? We can't rely on the old value, because the\n    // user might have been mucking with the scroll bars.\n    var container_dom = diagram.container_dom,\n        scroll_top = container_dom.scrollTop,\n        scroll_left = container_dom.scrollLeft;\n    var viewport = diagram.viewport = new Box(\n        scroll_top + canvas.top,\n        scroll_left,\n        scroll_top + canvas.top + min_canvas_height,\n        scroll_left + min_canvas_width\n    );\n    //viewport.log(\"viewport\");\n\n    // Compute where the new viewport will be. First move it to cover the\n    // cover box, then make sure it is within the canvas\n    var new_viewport = diagram.new_viewport = viewport.copy();\n    new_viewport.vmove(\n      cover_box.top < new_viewport.top ?\n        cover_box.top - new_viewport.top :\n      cover_box.bottom > new_viewport.bottom ?\n        cover_box.bottom - new_viewport.bottom :\n      0\n    );\n    new_viewport.vmove(\n      new_canvas.top > new_viewport.top ?\n        new_canvas.top - new_viewport.top :\n      new_canvas.bottom < new_viewport.bottom ?\n        new_canvas.bottom - new_viewport.bottom :\n      0\n    );\n    new_viewport.hmove(\n      cover_box.left < new_viewport.left ?\n        cover_box.left - new_viewport.left :\n      cover_box.right > new_viewport.right ?\n        cover_box.right - new_viewport.right :\n      0\n    );\n    new_viewport.hmove(\n      new_canvas.left > new_viewport.left ?   // should never happen, both are 0\n        new_canvas.left - new_viewport.left :\n      new_canvas.right < new_viewport.right ?\n        new_canvas.right - new_viewport.right :\n      0\n    );\n    //new_viewport.log(\"new_viewport\");\n\n    diagram.embiggenning = \n      new_canvas.width() > canvas.width() || \n      new_canvas.height() > canvas.height(); \n  };\n\n  // Resize the canvas\n  function resize_canvas(diagram) {\n    var container_dom = diagram.container_dom,\n        new_canvas = diagram.new_canvas,\n        w = new_canvas.width(),\n        h = new_canvas.height();\n    diagram.svg.style({\n      \"width\": w,\n      \"height\": h,\n    });\n    // The following lines are an ugly hack that seems to be necessary\n    // for webkit browsers, to get them to re-compute the scroll bars\n    // for the container div, once the child has resized.\n    container_dom.style.display = \"none\";\n    container_dom.style.display = \"block\";\n  }\n\n  // Here's a \"tweener\" function, for adjusting the scrollTop and scrollLeft\n  // properties of the container div. It's based on this code block,\n  // http://bl.ocks.org/humbletim/5507619.\n  function tweener(new_top, new_left) {\n    return function() {\n      // Here, `this` is container_dom\n      var top_i = d3.interpolateNumber(this.scrollTop, new_top);\n      var left_i = d3.interpolateNumber(this.scrollLeft, new_left);\n      return function(t) { \n        this.scrollTop = top_i(t); \n        this.scrollLeft = left_i(t);\n      };\n    };\n  }\n\n  // This returns a Promise that will scroll the \n  // canvas, both vertically and horizontally at the same time,\n  // if necessary.\n  function scroll_canvas(diagram) {\n    var new_viewport = diagram.new_viewport,\n        container_dom = diagram.container_dom;\n\n    // If the diagram is getting larger, we resize it first\n    if (diagram.embiggenning) resize_canvas(diagram);\n\n    new_scroll_top = new_viewport.top - diagram.new_canvas.top;\n    new_scroll_left = new_viewport.left;\n    //console.log(\"new_scroll _top = \" + new_scroll_top + \n    //            \", _left = \" + new_scroll_left);\n\n    return new Promise(function(resolve, reject) {\n      if (container_dom.scrollTop != new_scroll_top || \n          container_dom.scrollLeft != new_scroll_left) \n      {\n        diagram.container_d3.transition()\n          .duration(diagram.duration)\n          .tween(\"uniquetweenname1\", tweener(new_scroll_top, new_scroll_left))\n          .each(\"end\", function() {\n            resolve(\"done scroll_canvas to \" + new_scroll_top + \", \" + new_scroll_left);\n          })\n        ;\n      }\n      else {\n        resolve(\"scroll_canvas: nothing to do\");\n      }\n    });\n  }\n})();\n","// Utility to compress state strings, which are very sparse binary strings\n\n// For testing, so this module can work stand-alone\nif (typeof DtdDiagram == \"undefined\") DtdDiagram = function() {};\n\n(function() {\n  var debug = false;\n  var dbg = debug && (typeof window != \"undefined\") && window.console ? \n    console.log.bind(window.console) : function() {};\n\n  var b64_digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                   \"abcdefghijklmnopqrstuvwxyz\" +\n                   \"0123456789-.\";\n\n\n  var c = DtdDiagram.Compressor = {\n\n    compress: function(binstr) {\n      dbg(\"compressing original string: \" + binstr);\n      var rllc = c.rll_compress(binstr);\n      dbg(\"rll_compressed: \" + rllc);\n      var b64 = c.binstr_to_base64(rllc);\n      dbg(\"base64: \" + b64);\n      dbg(\"compression ratio: \" + (binstr.length / b64.length))\n      return b64;\n    },\n\n    // Convert a string of \"0\"s and \"1\"s to a base64 string\n    binstr_to_base64: function(binstr) {\n      var b = c.cap(binstr),\n          len = b.length,\n          b64 = \"\";\n      for (var i = 0; i < len; i += 6) {\n        var digit = parseInt(b.substr(i, 6), 2);\n        b64 += b64_digits.charAt(digit);\n      }\n      return b64;\n    },\n\n    // Add a trailing \"1\", and pad, such that number of binary digits\n    // is divisible by 6.\n    cap: function(binstr) { \n      var cp = binstr + \"1\" + \"0\".repeat(5 - binstr.length % 6); \n      dbg(\"capped: \" + cp);\n      return cp;\n    },\n\n    // Convert an integer to a binary string, padding with zeros to n\n    // digits\n    int_to_binary: function(i, n) {\n      var b = i.toString(2);\n      return \"0\".repeat(n - b.length) + b;\n    },\n\n    // Do the run-length compression, returning another binary string\n    rll_compress: function(s) {\n      var i = s.indexOf(\"1\");\n      var rllc = (\n        i == -1 ? \"\" :\n        (\n          i == 0  ? \"00\" :\n          i <= 4  ? \"01\" + c.int_to_binary(i-1, 2) :\n          i <= 20 ? \"10\" + c.int_to_binary(i-5, 4) :\n                    \"11\" + c.int_to_binary(i-21, 10)\n        ) + c.rll_compress(s.substr(i+1))\n      );\n      return rllc;\n    },\n\n  /////////////////////////////////////////////////////////////////////\n\n    decompress: function(b64str) {\n      dbg(\"decompressing: \" + b64str);\n      var rllc = c.base64_to_binstr(b64str);\n      dbg(\"rll_compressed: \" + rllc);\n      var binstr = c.rll_decompress(rllc);\n      dbg(\"final binary string: \" + binstr);\n      return binstr;\n    },\n\n    base64_to_binstr: function(b64) {\n      var capped = b64.split('').reduce(function(prev, d) {\n        var ds = b64_digits.indexOf(d).toString(2);\n        ds = \"0\".repeat(6 - ds.length) + ds;\n        return prev + ds;          \n      }, \"\");\n      dbg(\"  capped: \" + capped);\n      // Uncap:\n      var uncapped = capped.substr(0, capped.lastIndexOf(\"1\"))\n      dbg(\"  uncapped: \" + uncapped);\n      return uncapped;\n    },\n\n    rll_decompress: function(rllc) {\n      var b = \"\";\n      while (rllc.length > 0) {\n        var num_zeros;\n        var prefix = rllc.substr(0, 2);\n        if (prefix == \"00\") {\n          num_zeros = 0;\n          rllc = rllc.substr(2);\n        }\n        else if (prefix == \"01\") {\n          num_zeros = parseInt(rllc.substr(2, 2), 2) + 1;\n          rllc = rllc.substr(4);\n        }\n        else if (prefix == \"10\") {\n          num_zeros = parseInt(rllc.substr(2, 4), 2) + 5;\n          rllc = rllc.substr(6);\n        }\n        else {\n          num_zeros = parseInt(rllc.substr(2, 10), 2) + 21;\n          rllc = rllc.substr(12);\n        }\n        b += \"0\".repeat(num_zeros) + \"1\";\n      }\n      return b;\n    },\n  };\n\n\n\n\n\n\n  if (typeof module != \"undefined\") module.exports = c;\n\n})();\n","// StateManager - DtdDiagram methods for managing state. See Implementation.md,\n// \"Managing state\".\n\n// For testing, so this module can work stand-alone\nif (typeof DtdDiagram == \"undefined\") DtdDiagram = function() {};\n\n(function() {\n\n/*\n  // Bind to the popstate event\n  if (typeof window !== \"undefined\")\n    window.onpopstate = function(evt) {\n      console.log(\"popstate: %o\", evt.state);\n      var s = evt.state;\n      if (s) {\n        Object.keys(s).forEach(function(did) {\n          var diagram = DtdDiagram.diagrams_hash[did];\n          if (!diagram) return;\n          console.log(\"popping for \" + did);\n          var state = s[did];\n\n          diagram.set_current_root(state.current_root_addr);\n          diagram.set_ec_state(state.ec_state);\n\n          // If we're going forward, then change src_node first, then animate.\n          // If we're going back, animate, then change src_node\n          if (diagram.state_id < state.state_id) {\n            diagram.set_src_node(state.src_node_addr);\n            diagram.update();\n          }\n          else {\n            diagram.update();\n            diagram.set_src_node(state.src_node_addr);\n          }\n          diagram.state_id = state.state_id;\n        });\n      }\n    };\n*/\n\n  //-----------------------------------------------------------------------\n  // DtdDiagram methods\n\n  DtdDiagram.last_state_id = 0;\n\n  // This is called during diagram.initialize(), to get the initial state, either\n  // from a history state object, if there is one, or from the URL, if it's there.\n  // Otherwise, returns null.\n  DtdDiagram.prototype.get_initial_state = function() {\n    return null;\n  /*\n    var diagram = this;\n    if (history.state) return history.state[diagram.container_id] || null;\n\n    var url_state = diagram.get_url_state();\n    if (!url_state) return null;\n\n    return {\n      orig_root_name: url_state.root_name,\n      current_root_addr: \"0\",\n      ec_state: url_state.ec_state,\n      src_node_addr: url_state.src_node_addr,\n    };\n  */\n  };\n\n/*\n  // Parse the current location query string, and return an object for\n  // the diagram with the given container id. Or null.\n  // Example: ?d1=article!AF1b!7uI.\n  DtdDiagram.prototype.get_url_state = function() {\n    var diagram = this;\n    var qs = window.location.search;\n    if (!qs || qs.charAt(0) != '?') return;\n    var url_state = null;\n    qs.substr(1).split('&').forEach(function(id_val_str) {\n      // id_val_str => 'd1=article!AF1b!7uI'\n      var id_val = id_val_str.split('=');\n      if (id_val.length == 2 && id_val[0] == diagram.container_id) {\n        url_state = {};\n        var vals = id_val[1].split('!');\n        url_state = {\n          root_name: vals[0],\n          ec_state: (vals.length > 1 ? vals[1] : null),\n          src_node_addr: (vals.length > 2 ? vals[2] : null),\n        };\n      }\n    });\n    return url_state;\n  };\n*/\n\n/*\n  // This is called after a new diagram has been instantiated. It checks the\n  // history state object, and merges in this diagram's state data, then\n  // calls replaceState\n  DtdDiagram.prototype.update_state = function() {\n    var diagram = this;\n    var state = history.state || {};\n    var new_state_id = DtdDiagram.last_state_id++;\n    diagram.state_id = new_state_id;\n\n    state[diagram.container_id] = {\n      orig_root_name: diagram.orig_root_name,\n      current_root_addr: diagram.current_root_addr,\n      ec_state: diagram.ec_state,\n      src_node_addr: diagram.src_node_addr,\n      state_id: new_state_id,\n    };\n    // don't update the url, in this case\n    history.replaceState(state, null);\n  };\n*/\n\n  // Push state, after a change\n  DtdDiagram.prototype.push_state = function() {\n  /*\n    var diagram = this;\n    var dstate = {};\n    var new_state_id = DtdDiagram.last_state_id++;\n    diagram.state_id = new_state_id;\n\n    dstate[diagram.container_id] = {\n      orig_root_name: diagram.orig_root_name,\n      current_root_addr: diagram.current_root_addr,\n      ec_state: diagram.get_ec_state(),\n      src_node_addr: diagram.src_node_addr,\n      state_id: new_state_id,\n    };\n    // Combine this diagram's state with all the others\n    var state = DtdDiagram.extend(\n      {}, history.state, dstate\n    );\n\n    // Compute the new URL, which has the state for all the diagrams\n    var first = true;\n    var url = \"\";\n    Object.keys(state).forEach(function(k) {\n      var dso = state[k];  // diagram state object\n      var diag = DtdDiagram.diagrams_hash[k];\n      if (diag && dso && dso.orig_root_name) {\n        url += (first ? \"?\" : \"&\") + k + \"=\" + diag.current_root_node.name + \"!\" +\n               dso.ec_state + \"!\" + dso.src_node_addr;\n      }\n      first = false;\n    });\n    history.pushState(state, null, url);\n  */\n  };\n\n\n  //-----------------------------------------------------------------------\n  // Public getters and setters - use only these from outside this module,\n  // in order to maintain consistency of the state variables\n\n  // Set current root, either from a Node object, or from an address. If there's\n  // no argument, then this will use the diagram.current_root_addr to set the _node.\n  DtdDiagram.prototype.set_current_root = function(cr) {\n    var diagram = this;\n\n    if (typeof cr == \"object\") {\n      diagram.current_root_node = cr;\n      diagram.current_root_addr = cr.id;\n    }\n    else {\n      if (typeof cr == \"undefined\") cr = diagram.current_root_addr;\n      if (typeof diagram.nodes[cr] == \"undefined\") {\n        walk_to_node(diagram, diagram.orig_root_node, cr);\n      }\n      diagram.current_root_node = diagram.nodes[cr];\n    }\n  };\n\n\n  // Get the diagram's expand/collapse state as a base64 string\n  DtdDiagram.prototype.get_ec_state = function() {\n    var s = this.current_root_node.state();\n    return this.ec_state = DtdDiagram.Compressor.compress(s);\n  };\n\n  // Set the diagram's expand/collapse state, based on the current\n  // values of current_root_node and ec_state. If there is no argument,\n  // then the current ec_state value will be used.\n  DtdDiagram.prototype.set_ec_state = function(s) {\n    if (typeof s !== \"undefined\") {\n      this.ec_state = s;\n    }\n    var binstr = DtdDiagram.Compressor.decompress(this.ec_state);\n    this.current_root_node.set_ec_state(binstr);\n  };\n\n\n  // Set the src_node, either from an address (relative to the current root)\n  // or from an ElementNode object. If no argument is given, this will use\n  // diagram.src_node_addr to set the src_node object.\n  DtdDiagram.prototype.set_src_node = function(sn) {\n    var diagram = this;\n\n    if (typeof sn == \"object\") {\n      diagram.src_node = sn;\n      diagram.src_node_addr =\n        node_relative_addr(diagram.current_root_addr, sn.id);\n    }\n    else {\n      if (typeof sn == \"undefined\") sn = diagram.src_node_addr;\n      var sn_abs_addr = diagram.current_root_addr + (sn == \"\" ? \"\" : (\",\" + sn));\n      if (typeof diagram.nodes[sn_abs_addr] == \"undefined\") {\n        walk_to_node(diagram, diagram.current_root_node, sn_abs_addr);\n      }\n      diagram.src_node = diagram.nodes[sn_abs_addr];\n    }\n  };\n\n\n  //-----------------------------------------------------------------------\n  // Utility functions\n\n  // Compute the address of a node relative to some other node\n  function node_relative_addr(base, n) {\n    return n.substr(base.length + 1);\n  };\n\n  // Walk the tree out to a given node address, in order to instantiate\n  // all the intervening nodes. end_addr is the absolute address of the\n  // target node.\n  function walk_to_node(diagram, start_node, end_addr) {\n    var rel_addr = node_relative_addr(start_node.id, end_addr);\n    var addr = rel_addr.split(\",\");\n    var n = start_node;\n    var ni;\n    while (typeof (nistr = addr.shift()) != \"undefined\") {\n      var ni = parseInt(nistr);\n      n = n.get_child(ni);\n    }\n    return n;\n  }\n\n\n})();\n"],"sourceRoot":"/source/"}